The primary function of a web server is to 
	store,
	process
	and deliver 
		web pages to clients.


Pages delivered are most frequently 
	HTML documents, which may include 
		images,
		style sheets 
		and scripts 
			in addition to the text content



INPUT : A user agent, commonly a web browser or web crawler, initiates communication by
making a request for a specific resource using HTTP

OUPUT : and the server responds with the content of that resource or an error message if unable to do so. 

a full implementation of HTTP also
includes ways of receiving content from clients. This feature is used for submitting web
forms, including uploading of files.


Allowed functions : 
	malloc, free, write, open, read, close, mkdir,
	rmdir, 
		unlink,
	fork, wait, waitpid, wait3, wait4,
	signal, kill, exit, getcwd, chdir, stat, lstat,
	fstat, lseek, opendir, readdir, closedir, execve,
	dup, dup2, pipe, strerror, errno, gettimeofday,

		strptime, strftime,
	usleep,
		select, socket, accept, listen, send, recv, bind, connect, inet_addr,
		setsockopt, getsockname, fcntl

You can include and use everything in "iostream" "string" "vector" "list" "queue"
"stack" "map" "algorithm" "exception"

/!\
	You can only use fcntl as follow: fcntl(fd, F_SETFL, O_NONBLOCK);
	Any other flags is forbidden
/!\

It must be conditionnal compliant with the rfc 7230 to 7235 (http 1.1) but you need
to implement only the following headers
	◦ Accept-Charsets
	◦ Accept-Language
	◦ Allow
	◦ Authorization
	◦ Content-Language
	◦ Content-Length (/!\)
	◦ Content-Location
	◦ Content-Type (/!\)
	◦ Date
	◦ Host (/!\)
	◦ Last-Modified
	◦ Location (/!\)
	◦ Referer
	◦ Retry-After
	◦ Server
	◦ Transfer-Encoding (/!\)
	◦ User-Agent
	◦ WWW-Authenticate

headers that are unknown -> must be parsed and transformed into Environment variables

nginx is HTTP 1.1 compliant and may be use to compare headers and answer behaviors

/!\ It must be non blocking and use only 1 select for all the IO between the client and
the server (listens includes). /!\

/!\ Select should check read and write at the same time.
/!\ Your server should never block and client should be bounce properly if necessary
/!\ You should never do a read operation or a write operation without going through select
/!\ Checking the value of errno is strictly forbidden after a read or a write operation
/!\ A request to your server should never hang forever
/!\ You server should have default error pages if none are provided
/!\ You can’t use fork for something else than CGI (like php or perl or ruby etc...)
/!\ Your program should have a config file in argument or use a default path

/!\ 
	Your program should not leak and should never crash, (even when out of memory
	if all the initialisation is done)
/!\ 

/!\
	We’ve let you use fcntl because mac os X doesn’t implement write the
	same way as other unix OS.
	You must use non-blocking FD to have a result similar to other OS.
/!\

/!\
	Because you are using non-blocking FD, you could use read/recv or
	write/send functions without select and your server would be not
	blocking.
	Again trying to read/recv or write/send in any FD without going
	through a select will give you a mark equal to 0 and the end of the
	evaluation.
/!\

Config-file (cf nginx.conf):
- port and host of each 'server'
- server_names (if necessary)
- The first server for a host:port will be the default for this host:port (meaning
it will answer to all request that doesn’t belong to an other server)
- default error pages
- limit client body size
- setup routes that can accept one or multiple of the following rules/configuration (routes
	wont be using regexp):
	∗ define a list of accepted HTTP Methods for the route
	∗ define a directory or a file from where the file should be search (for example
		if url /kapouet is rooted to /tmp/www, url /kapouet/pouic/toto/pouet is
		/tmp/www/pouic/toto/pouet)
	∗ turn on or off directory listing
	∗ default file to answer if the request is a directory
	∗ execute CGI based on certain file extension (for example .php)
		· You wonder what a CGI is go? https://en.wikipedia.org/wiki/Common_Gateway_Interface
		· Because you wont call the cgi directly use the full path as PATH_INFO
		· Just remember that for chunked request, your server need to unchunked it and the CGI will expect EOF as end of the body.
			· Same things for the output of the CGI. if no content_length is returned
				from the CGI, EOF will mean the end of the returned data.
		· Your program should set the following Meta-Variables
			AUTH_TYPE
			CONTENT_LENGTH
			CONTENT_TYPE
			GATEWAY_INTERFACE
			PATH_INFO
			PATH_TRANSLATED
			QUERY_STRING
			REMOTE_ADDR
			REMOTE_IDENT
			REMOTE_USER
			REQUEST_METHOD
			REQUEST_URI
			SCRIPT_NAME
			SERVER_NAME
			SERVER_PORT
			SERVER_PROTOCOL
			SERVER_SOFTWARE
		· Your program should call the cgi with the file requested as first argument
		· the cgi should be run in the correct directory for relativ path file access
		· your server should work with php-cgi
	∗ make the route able to accept uploaded files and configure where it should
		be saved