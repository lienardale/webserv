The primary function of a web server is to 
	store,
	process
	and deliver 
		web pages to clients.


Pages delivered are most frequently 
	HTML documents, which may include 
		images,
		style sheets 
		and scripts 
			in addition to the text content



INPUT : A user agent, commonly a web browser or web crawler, initiates communication by
making a request for a specific resource using HTTP

OUPUT : and the server responds with the content of that resource or an error message if unable to do so. 

a full implementation of HTTP also
includes ways of receiving content from clients. This feature is used for submitting web
forms, including uploading of files.


Allowed functions : 
	malloc, free, write, open, read, close, mkdir,
	rmdir, 
		unlink,
	fork, wait, waitpid, wait3, wait4,
	signal, kill, exit, getcwd, chdir, stat, lstat,
	fstat, lseek, opendir, readdir, closedir, execve,
	dup, dup2, pipe, strerror, errno, gettimeofday,

		strptime, strftime,
	usleep,
		select, socket, accept, listen, send, recv, bind, connect, inet_addr,
		setsockopt, getsockname, fcntl

You can include and use everything in "iostream" "string" "vector" "list" "queue"
"stack" "map" "algorithm" "exception"

/!\
	You can only use fcntl as follow: fcntl(fd, F_SETFL, O_NONBLOCK);
	Any other flags is forbidden
/!\

It must be conditionnal compliant with the rfc 7230 to 7235 (http 1.1) but you need
to implement only the following headers
	◦ Accept-Charsets
	◦ Accept-Language
	◦ Allow
	◦ Authorization
	◦ Content-Language
	◦ Content-Length (/!\)
	◦ Content-Location
	◦ Content-Type (/!\)
	◦ Date
	◦ Host (/!\)
	◦ Last-Modified
	◦ Location (/!\)
	◦ Referer
	◦ Retry-After
	◦ Server
	◦ Transfer-Encoding (/!\)
	◦ User-Agent
	◦ WWW-Authenticate

headers that are unknown -> must be parsed and transformed into Environment variables

nginx is HTTP 1.1 compliant and may be use to compare headers and answer behaviors

/!\ It must be non blocking and use only 1 select for all the IO between the client and
the server (listens includes). /!\

/!\ Select should check read and write at the same time.
/!\ Your server should never block and client should be bounce properly if necessary
/!\ You should never do a read operation or a write operation without going through select
/!\ Checking the value of errno is strictly forbidden after a read or a write operation
/!\ A request to your server should never hang forever
/!\ You server should have default error pages if none are provided
/!\ You can’t use fork for something else than CGI (like php or perl or ruby etc...)
/!\ Your program should have a config file in argument or use a default path

/!\ 
	Your program should not leak and should never crash, (even when out of memory
	if all the initialisation is done)
/!\ 

/!\
	We’ve let you use fcntl because mac os X doesn’t implement write the
	same way as other unix OS.
	You must use non-blocking FD to have a result similar to other OS.
/!\

/!\
	Because you are using non-blocking FD, you could use read/recv or
	write/send functions without select and your server would be not
	blocking.
	Again trying to read/recv or write/send in any FD without going
	through a select will give you a mark equal to 0 and the end of the
	evaluation.
/!\
